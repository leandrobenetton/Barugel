/****** Object:  StoredProcedure [dbo].[ZWM_GetImportedGrnSp]    Script Date: 01/09/2015 14:43:01 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[ZWM_GetImportedGrnSp]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[ZWM_GetImportedGrnSp]
GO

/****** Object:  StoredProcedure [dbo].[ZWM_GetImportedGrnSp]    Script Date: 01/09/2015 14:43:01 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[ZWM_GetImportedGrnSp] 
(
@pGrnNum      GrnNumType		= NULL
,@pPoNum      PoNumType			= NULL
,@pPackNum    VendInvoiceType	= NULL
,@Infobar     InfobarType		= NULL OUTPUT
)
AS

-- Check for existence of Generic External Touch Point routine (this section was generated by SpETPCodeSp and inserted by CallETPs.exe):
   IF OBJECT_ID(N'dbo.EXTGEN_ZWM_GetImportedGrnSp') IS NOT NULL
   BEGIN
      DECLARE @EXTGEN_SpName sysname
      SET @EXTGEN_SpName = N'dbo.EXTGEN_ZWM_GetImportedGrnSp'
      -- Invoke the ETP routine, passing in (and out) this routine's parameters:
      DECLARE @EXTGEN_Severity int
      EXEC @EXTGEN_Severity = @EXTGEN_SpName
		@pGrnNum      
		,@pPoNum      
		,@pPackNum    
		,@Infobar      OUTPUT	
 
      -- ETP routine can RETURN 1 to signal that the remainder of this standard routine should now proceed:
      IF @EXTGEN_Severity <> 1
         RETURN @EXTGEN_Severity
   END
   -- End of Generic External Touch Point code.
   

DECLARE 
 @ZWMGrnNum       GrnNumType
,@ZWMPoNum        PoNumType
,@ZWMBarCode      ZwmBarCodeType
,@ZWMItem         ItemType
,@ZWMQtyShipped   QtyTotlType
,@PoLine          PoLineType

DECLARE
@PoItemQtyOrderedConv   QtyUnitType
,@GrnLineQtyShippedConv QtyUnitType
,@Severity     int
,@ConvpPoNum PoNumType

UPDATE poitem
SET ZWM_QtyShipped = 0
WHERE poitem.po_num = @pPoNum

SET @Severity = 0

	DECLARE ZWMCursor CURSOR LOCAL STATIC FOR

	SELECT imp.po_num
      ,isnull(imp.item,item.item)
      ,SUM(imp.qty_shipped)
      FROM zwm_imported_grn_mst imp 
      LEFT JOIN item ON item.ZWM_BarCode = imp.bar_code
	WHERE pack_number = @pPackNum
	AND po_num = @pPoNum
	GROUP BY imp.pack_number,imp.po_num,isnull(imp.item,item.item)
	
OPEN ZWMCursor

WHILE 1=1
BEGIN

   -- Normalmente la primer sentencia es un FETCH
   FETCH ZWMCursor INTO 
                   @ZWMPoNum  
                   ,@ZWMItem        
                   ,@ZWMQtyShipped 
       -- La lista de variables debe coincidir en orden y cantidad a las definidas en el SELECT

      IF @@FETCH_STATUS <> 0 -- El valor cero es cuando pudo leer un registro, cuando es EOF regresa <> 0
          BREAK      -- Para salir del While BEGIN END

       -- Obtener el numero de po_line
      SELECT TOP 1 @PoLine = po_line
          ,@PoItemQtyOrderedConv = qty_ordered_conv 
          FROM poitem
          WHERE po_num = @pPoNum
              AND item  = @ZWMItem
              ORDER BY po_line

       -- Obtener el total ya acumulado o ya generado en grn_lines para la PO y Linea
      SELECT @GrnLineQtyShippedConv = ISNULL(SUM(qty_shipped_conv),0)   -- Utilizo ISNULL en caso que no haya nada y regrese NULL
                  FROM grn_line
                  WHERE po_num = @pPoNum
                  AND po_line = @PoLine

   
      -- Compara la cantidad ordenada de la linea vs la cantidad embarcada de zwm_grn_imported
      IF (@PoItemQtyOrderedConv - @GrnLineQtyShippedConv) >= @ZWMQtyShipped  -- La cantidad a generar es menor, esta OK

          BEGIN
              UPDATE poitem SET ZWM_QtyShipped = @ZWMQtyShipped
              WHERE po_num = @pPoNum
				AND po_line = @PoLine
                AND po_release = 0
                
                set @ZWMQtyShipped = 0
				select @ZWMQtyShipped as remanente
				
          END
          
      ELSE    -- La cantidad embarcada supera la cantidad ordenada - la importada previamente
          BEGIN
          
          DECLARE 
          @PoLines PoLineType --para recorrer todas las lineas
          ,@QtyLine QtyUnitType --cantidad de la linea actual
 
		  --primera linea
		  SELECT @PoLines = min( po_line ) FROM poitem WHERE po_num = @pPoNum AND item = @ZWMItem 
		  
		  WHILE @PoLines is not null
		  BEGIN

			--cantidad ordenada de la linea actual
			SET @QtyLine = (SELECT qty_ordered_conv 
			FROM poitem 
			WHERE po_num = @pPoNum 
			AND item = @ZWMItem
			AND po_line = @PoLines)

			 --si la cantidad pedida en la linea actual es menor o igual a la embarcada, la ZWM_QtyShipped es = a la cantidad pedida.			
			IF @QtyLine <= @ZWMQtyShipped			
			BEGIN

				UPDATE poitem_mst 
					SET ZWM_QtyShipped = @QtyLine
					  WHERE po_num = @pPoNum
						   AND po_line = @PoLines
						   AND po_release = 0
							   
					-- cantidad embarcada remanente, le resto lo que le asigne a la linea
					set @ZWMQtyShipped = @ZWMQtyShipped - @QtyLine
							select @ZWMQtyShipped as remanente
			END
			
			--cantidad pedida (linea actual) mayor a la cantidad embarcada (siempre que haya cantidad embarcada)
			ELSE IF (@QtyLine > @ZWMQtyShipped AND @ZWMQtyShipped > 0)
			BEGIN
				UPDATE poitem 
					SET ZWM_QtyShipped = @ZWMQtyShipped
					  WHERE po_num = @pPoNum
						   AND po_line = @PoLines
						   AND po_release = 0
							   
					set @ZWMQtyShipped = @ZWMQtyShipped - @QtyLine
			END
			
			--siguiente po_line
			select @PoLines = min(po_line) from poitem where po_line > @PoLines and po_num = @pPoNum

		  end

          END
          
END

IF @ZWMQtyShipped > 0
	BEGIN
		set @Infobar = 'Se enviaron mas productos que los pedidos'
		set @Severity = 1
	END

CLOSE ZWMCursor
DEALLOCATE ZWMCursor

RETURN @Severity

GO


