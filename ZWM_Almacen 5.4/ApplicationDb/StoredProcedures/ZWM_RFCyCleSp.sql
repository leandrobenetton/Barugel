/****** Object:  StoredProcedure [dbo].[ZWM_RFCyCleSp]    Script Date: 01/20/2015 15:11:52 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[ZWM_RFCyCleSp]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[ZWM_RFCyCleSp]
GO

/****** Object:  StoredProcedure [dbo].[ZWM_RFCyCleSp]    Script Date: 01/20/2015 15:11:52 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO




CREATE PROCEDURE [dbo].[ZWM_RFCyCleSp](
     @Site			 SiteType
	,@UserName		 UserNameType		= NULL
	,@Item			 ItemType			= NULL
	,@QtyUMStd       QtyUnitType		= NULL
	,@QtyUMStk1      QtyUnitType		= NULL
	,@QtyUMStk2		 QtyUnitType		= NULL
	,@Whse			 WhseType			= NULL
	,@Loc			 LocType			= NULL
	,@Lot			 LotType			= NULL
	,@AddCount		 FlagNyType			= NULL
	,@DelLoc		 FlagNyType			= NULL
    ,@Emp			 EmpNumType			= NULL
	,@Infobar		 InfobarType		= NULL OUTPUT
)
AS

   -- Check for existence of Generic External Touch Point routine (this section was generated by SpETPCodeSp and inserted by CallETPs.exe):
   IF OBJECT_ID(N'dbo.EXTGEN_ZWM_RFCyCleSp') IS NOT NULL
   BEGIN
      DECLARE @EXTGEN_SpName sysname
      SET @EXTGEN_SpName = N'dbo.EXTGEN_ZWM_RFCyCleSp'
      -- Invoke the ETP routine, passing in (and out) this routine's parameters:
      DECLARE @EXTGEN_Severity int
      EXEC @EXTGEN_Severity = @EXTGEN_SpName
	     @Site
		,@UserName
		,@Item
		,@QtyUMStd
		,@QtyUMStk1
		,@QtyUMStk2
		,@Whse
		,@Loc
		,@AddCount
		,@DelLoc
		,@Emp
		,@Infobar
 
      -- ETP routine can RETURN 1 to signal that the remainder of this standard routine should now proceed:
      IF @EXTGEN_Severity <> 1
         RETURN @EXTGEN_Severity
   END
   -- End of Generic External Touch Point code.

--Inicio de Sesion
DECLARE	@return_value int,
		@sessionId            RowPointerType

SET @UserName = isnull(@UserName,'sa')

EXEC	@return_value = [dbo].[InitSessionContextWithUserSp]
		@ContextName = 'ZWM',
		@UserName = @UserName,
		@SessionID = @SessionID OUTPUT,
		@Site = @Site

--Solo para implementacion Barugel Azulay
DECLARE @BAR FlagNyTYpe
IF (Select count(*) from zwm_parms where customer = 'BAR') > 0
	Set @BAR = 1 


----------------------------------------------------------------------- VARIABLES
DECLARE @Severity int
SET @Severity = 0

DECLARE 
@CountQty				QtyUnitType			    -- cantidad a mover. 
,@LotTracked			ListYesNoType				-- controla lote
,@ParmsLotGenExp		ListYesNoType
,@RecordProcessed		int

-- variables para la conversión de unidades
DECLARE
@UMItem               UMType
,@QtyStk1Converted     QtyUnitType
,@QtyStk2Converted     QtyUnitType
,@OutQty               int
,@UMStk1			   UMType
,@UMStk2			   UMType

SET @QtyStk1Converted = 0
SET @QtyStk2Converted = 0
SET @QtyUMStd = ISNULL(@QtyUMStd,0)
SET @QtyUMStk1 = ISNULL(@QtyUMStk1,0)
SET @QtyUMStk2 = ISNULL(@QtyUMStk2,0)

SET @DelLoc = ISNULL(@DelLoc,0)
SET @AddCount = ISNULL(@AddCount,0)

------------------------------ SET NULLs
IF len(ltrim(rtrim(@Lot))) = 0 SET @Lot = NULL
------------------------------ SET NULLs

SELECT @ParmsLotGenExp = invparms.lot_gen_exp FROM invparms
IF EXISTS(SELECT * FROM item WITH (READUNCOMMITTED) WHERE item.item = @Item) AND @ParmsLotGenExp = 1
BEGIN
   SET @Lot = RTRIM(@Lot)
   SET @Lot = dbo.ExpandKyByType('LotType',@Lot)
END

SET @Emp = dbo.ExpandKyByType('EmpNumType', @Emp)

--Desarrollado solo para Barugel dado que desea validar que lo que esta siendo contado pertenzca a una familia existente en una tabla particular, solo custom Barugel
IF @BAR = 1 And @DelLoc = 0 And Exists (Select * from sys.tables where name = 'BAR_Cycle')
BEGIN
	IF (Select count(*) From Bar_CyCle where Whse = @Whse) = 0
	BEGIN
		SET @Infobar = 'Avise a Sistemas, tabla de validacion de conteo no cargada'
		SET @Severity = 16
		RETURN @severity
	END
	ELSE IF (Select count(*) From Bar_CyCle where Whse = @Whse) > 0
		And (Select count(*) from item i inner join BAR_CyCle barc on barc.product_code = i.product_Code where i.item = @item) = 0
		And (Select count(*) from item i inner join BAR_CyCle barc on barc.family_code = i.family_Code where i.item = @item) = 0
	BEGIN
		SET @Infobar = 'No debe contar el articulo'
		SET @Severity = 16
		RETURN @severity
	END
END

------------------------------------------------------------------------ SPs
--convierte las cantidades de Stk1 a UM estandar
IF @QtyUMStk1 > 0
BEGIN
	SET @UMStk1 = ( SELECT ZWM_UMStock1 FROM item WHERE item = @Item )
	EXEC @Severity = dbo.UMConvQtySp
		@UM               = @UMStk1
	  , @Item             = @Item
	  , @VendNum          = NULL
	  , @Area             = NULL
	  , @ConvertToBase    = 1
	  , @QtyToBeConverted = @QtyUMStk1
	  , @OutQty           = @QtyStk1Converted OUTPUT --devuelve la cantidad convertida
	  , @Infobar          = @Infobar       OUTPUT
END

--convierte las cantidades de Stk2 a UM estandar
IF @QtyUMStk2 > 0
BEGIN 
	SET @UMStk2 = ( SELECT ZWM_UMStock2 FROM item WHERE item = @Item )
	EXEC @Severity = dbo.UMConvQtySp
		@UM               = @UMStk2
	  , @Item             = @Item
	  , @VendNum          = NULL
	  , @Area             = NULL
	  , @ConvertToBase    = 1
	  , @QtyToBeConverted = @QtyUMStk2
	  , @OutQty           = @QtyStk2Converted OUTPUT --devuelve la cantidad convertida
	  , @Infobar          = @Infobar       OUTPUT
END

------------------------------------------------------------------------ Seteo de variables
--cantidad a mover.
SET @CountQty = @QtyUMStd + @QtyStk1Converted + @QtyStk2Converted 

-- Si el parámetro de depósito es NULL, tomar el depósito principal, sino verifica que exista
IF @Whse IS NULL
		SELECT @Whse = def_whse FROM invparms
ELSE IF(SELECT Whse FROM Whse WHERE whse = @Whse) IS NULL
BEGIN
	SET @Infobar = 'El almacén no existe'
	SET @Severity = 16
	RETURN @severity
END

-- Si el parámetro de ubicación es NULL, tomar la ubicación de recepcion; caso contrario verificar que la ubicación exista
IF(SELECT loc FROM location WHERE loc = @Loc) IS NULL
	BEGIN
		SET @Infobar = 'La ubicación no existe'
		SET @Severity = 16
		RETURN @severity
	END

--Verifica que el artículo exista
IF (select count(item) from item where item = @Item) = 0 and @DelLoc = 0
BEGIN
	SET @Infobar = 'No existe el artículo'
	SET @Severity = 16
	RETURN @severity
END

-- El articulo controla lote
SELECT @LotTracked = lot_tracked FROM item WHERE item = @Item

IF @LotTracked = 1 and (@Lot is null or @Lot = '') and @DelLoc = 0
BEGIN
	SET @Infobar = 'Debe informar lote'
	SET @Severity = 16
	RETURN @severity
END

IF @CountQty = 0 and @DelLoc = 0
BEGIN
	SET @Infobar = 'Debe informar cantidad'
	SET @Severity = 16
	RETURN @severity
END

--Criterio de reservas (falta incorporar)


--Conteo Cíclico

BEGIN TRANSACTION

	--Creo la relacion del item con ubicacion y deposito
IF (SELECT TOP 1 Loc FROM ItemLoc WHERE ItemLoc.item = @Item and ItemLoc.whse = @whse and ItemLoc.loc = @Loc) IS NULL and @DelLoc = 0
BEGIN
	EXEC	@Severity = [dbo].[ItemWhstkSp]
			@PBegItem = @Item,
			@PEndItem = @Item,
			@PWhse = @whse,
			@PLoc = @Loc,
			@PMrbFlag = 0,
			@PPermFlag = 0,
			@RecordProcessed = @RecordProcessed OUTPUT,
			@Infobar = @Infobar OUTPUT
END

IF (SELECT TOP 1 lot FROM Lot WHERE Lot.item = @Item and Lot.lot = @Lot) IS NULL
BEGIN
EXEC	@Severity = [dbo].[LotAddSp]
		@Item = @Item,
		@Lot = @Lot,
		@RcvdQty = 0,
		@FromPO = 0,
		@VendLot = NULL,
		@CreateNonUnique = NULL,
		@Infobar = @Infobar OUTPUT,
		@Site = @Site
END

IF  @DelLoc = 0 And @LotTracked = 0 And (Select count(*) FROM Cycle WHERE item = @Item and whse = @whse and loc = @Loc) = 0
BEGIN
	insert into cycle (whse, item, loc, lot, ser_num
	, cut_off_qty, count_qty, stat, cycle_date)
	select @Whse, @item, @loc, NULL, NULL
	,0, NULL, 'N', getdate()

	update itemwhse
	set cnt_in_proc = 1
	from itemwhse
	where whse = @whse and item = @item and cnt_in_proc = 0
END
IF  @DelLoc = 0 And @LotTracked = 1 And (Select count(*) FROM Cycle WHERE item = @Item and whse = @whse and loc = @Loc and lot = @lot) = 0
BEGIN
	insert into cycle (whse, item, loc, lot, ser_num
	, cut_off_qty, count_qty, stat, cycle_date)
	select @Whse, @item, @loc, @lot, NULL
	,0, NULL, 'N', getdate()

	update itemwhse
	set cnt_in_proc = 1
	from itemwhse
	where whse = @whse and item = @item and cnt_in_proc = 0
END

IF @DelLoc = 0
BEGIN
	IF @LotTracked = 1 And @AddCount = 0
    BEGIN
       -- Update the cycle record.
       UPDATE cycle
       SET stat = 'C', count_qty = @CountQty
       WHERE whse = @Whse
         AND item = @Item
         AND loc  = @Loc
         AND ISNULL(lot, NCHAR(1)) = ISNULL(@Lot, NCHAR(1))
    END
    ELSE  IF @LotTracked = 0 And @AddCount = 0
    BEGIN
       -- Update the cycle record.
       UPDATE cycle
       SET stat = 'C', count_qty = @CountQty
       WHERE whse = @Whse
         AND item = @Item
         AND loc  = @Loc
    END
	ELSE IF @LotTracked = 1 And @AddCount = 1
    BEGIN
       -- Update the cycle record.
       UPDATE cycle
       SET stat = 'C', count_qty = @CountQty + count_qty
       WHERE whse = @Whse
         AND item = @Item
         AND loc  = @Loc
         AND ISNULL(lot, NCHAR(1)) = ISNULL(@Lot, NCHAR(1))
    END
    ELSE IF @LotTracked = 0 And @AddCount = 1
	BEGIN
       -- Update the cycle record.
       UPDATE cycle
       SET stat = 'C', count_qty = @CountQty + count_qty
       WHERE whse = @Whse
         AND item = @Item
         AND loc  = @Loc
    END
END
ELSE IF @DelLoc = 1
BEGIN
       UPDATE cycle
       SET stat = 'C', count_qty = 0
       WHERE whse = @Whse
         AND loc  = @Loc
END

IF @Severity <> 0
BEGIN
	ROLLBACK TRANSACTION
	SET @Infobar = 'Se encontro un error en el proceso, verifique los datos ingresados no procesados'
	RETURN @Severity
END
ELSE
	COMMIT TRANSACTION

EXEC dbo.CloseSessionContextSp @SessionID = @SessionID

RETURN @Severity





GO


