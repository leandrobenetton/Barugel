/****** Object:  StoredProcedure [dbo].[ZWM_CycleGenerationSp]    Script Date: 01/09/2015 14:36:00 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[ZWM_CycleGenerationSp]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[ZWM_CycleGenerationSp]
GO

/****** Object:  StoredProcedure [dbo].[ZWM_CycleGenerationSp]    Script Date: 01/09/2015 14:36:00 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


/* $Header: /ApplicationDB/Stored Procedures/ZWM_CycleGenerationSp.sp 16    12/27/13 12:20p pgross $ */
/*
***************************************************************
*                                                             *
*                           NOTICE                            *
*                                                             *
*   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
*   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
*   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
*   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
*   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
*   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
*   ALL OTHER RIGHTS RESERVED.                                *
*                                                             *
*   (c) COPYRIGHT 2010 INFOR.  ALL RIGHTS RESERVED.           *
*   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
*   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
*   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
*   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
*   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
*                                                             *
*************************************************************** 
*/
/* $Archive: /ApplicationDB/Stored Procedures/ZWM_CycleGenerationSp.sp $
 *
 * SL9.00 16 173407 pgross Fri Dec 27 12:20:22 2013
 * Cycle Count Posting still allow during freeze inventory
 * prevent processing when a Physical Inventory is in process
 *
 * SL8.02 15 rs4588 Dahn Thu Mar 04 10:30:56 2010
 * RS4588 Copyright header changes
 *
 * SL8.02 14 rs4588 Dahn Thu Mar 04 10:02:32 2010
 * RS4588 Copyright header changes
 *
 * SL8.01 13 rs3953 Vlitmano Tue Aug 26 16:44:30 2008
 * RS3953 - Changed a Copyright header?
 *
 * SL8.01 12 rs3953 Vlitmano Mon Aug 18 15:09:33 2008
 * Changed a Copyright header information(RS3959)
 *
 * SL8.00 11 100066 pgross Tue Mar 06 12:06:08 2007
 * Cycle Count Generation not generating for item
 * process items with a NULL plan_code
 *
 * SL8.00 10 rs2968 nkaleel Fri Feb 23 01:26:05 2007
 * changing copyright information
 *
 * SL8.00 9 97675 hcl-jmishra Wed Nov 15 05:00:20 2006
 * Cycle Count Generation - is not using the Planner code properly when generating items to be counted.
 * Issue #97675
 * Modified the code of the SP so as to filter correct planner code during CycleCountGeneration.
 *
 * SL8.00 8 RS2968 prahaladarao.hs Thu Jul 13 02:50:29 2006
 * RS 2968, Name change CopyRight Update.
 *
 * SL8.00 7 RS2968 prahaladarao.hs Tue Jul 11 05:50:21 2006
 * RS 2968
 * Name change CopyRight Update.
 *
 * SL7.05 6 91818 NThurn Fri Jan 06 14:43:05 2006
 * Inserted standard External Touch Point call.  (RS3177)
 *
 * SL7.04 5 91078 Hcl-singsun Tue Dec 27 02:27:06 2005
 * Add WITH (READUNCOMMITTED) to lot_loc selects
 * Issue #91078
 * Added WITH (READUNCOMMITTED) on select.
 *
 * $NoKeywords: $
 */
CREATE PROCEDURE [dbo].[ZWM_CycleGenerationSp] (
  @Whse WhseType
, @CycleType NVARCHAR(8)
, @MatlType NVARCHAR(8)
, @ABCCode NVARCHAR(8)
, @OverwriteRecords ListYesNoType
, @SortBy NVARCHAR(8) -- LOT or LOC
, @PageBetween ListYesNoType
, @PrintCutoffQty ListYesNoType
, @FromItem ItemType
, @ToItem ItemType
, @FromLoc LocType
, @ToLoc LocType
, @FromZone DescriptionType
, @ToZone	DescriptionType
, @FromProductCode ProductCodeType
, @ToProductCode ProductCodeType
, @FromFamilyCode FamilyCodeType
, @ToFamilyCode FamilyCodeType
, @FromPlanCode UserCodeType
, @ToPlanCode UserCodeType
, @Infobar InfobarType output
)
AS

   -- Check for existence of Generic External Touch Point routine (this section was generated by SpETPCodeSp and inserted by CallETPs.exe):
   IF OBJECT_ID(N'dbo.EXTGEN_ZWM_CycleGenerationSp') IS NOT NULL
   BEGIN
      DECLARE @EXTGEN_SpName sysname
      SET @EXTGEN_SpName = N'dbo.EXTGEN_ZWM_CycleGenerationSp'
      -- Invoke the ETP routine, passing in (and out) this routine's parameters:
      DECLARE @EXTGEN_Severity int
      EXEC @EXTGEN_Severity = @EXTGEN_SpName
         @Whse
         , @CycleType
         , @MatlType
         , @ABCCode
         , @OverwriteRecords
         , @SortBy
         , @PageBetween
         , @PrintCutoffQty
         , @FromItem
         , @ToItem
         , @FromLoc
         , @ToLoc
         , @FromZone
         , @ToZone
         , @FromProductCode
         , @ToProductCode
         , @FromFamilyCode
         , @ToFamilyCode
         , @FromPlanCode
         , @ToPlanCode
         , @Infobar OUTPUT
 
      -- ETP routine can RETURN 1 to signal that the remainder of this standard routine should now proceed:
      IF @EXTGEN_Severity <> 1
         RETURN @EXTGEN_Severity
   END
   -- End of Generic External Touch Point code.
 
declare @Severity int
, @I int
, @C NVARCHAR
, @Today DateType
, @Flag ListYesNoType
, @HaveLotLoc ListYesNoType
, @HaveSerial ListYesNoType
, @CycleInProc ListYesNoType
, @NumProcessed int
, @LowChar HighLowCharType
, @HighChar HighLowCharType

declare
  @Item ItemType
, @Loc LocType
, @ItemLotTracked ListYesNoType
, @ItemSerialTracked ListYesNoType
, @ItemStat ItemStatusType
, @ItemwhseRowPointer RowPointerType
, @ItemwhseCycleType CycleTypeType
, @ItemwhseLastCycle DateType
, @ItemwhseCycleFreq CycleFreqType
, @ItemwhseCycleFlag ListYesNoType
, @ItemwhseCntInProc ListYesNoType
, @ItemlocQtyOnHand QtyUnitType
, @LocationDescription DescriptionType
, @SerialLot LotType
, @SerialSerNum SerNumType
, @CycleRowPointer RowPointerType
, @LotLocQtyOnHand QtyUnitType
, @LotLocLot LotType

declare @CycleNew table (
  item ItemType
, loc LocType
, lot LotType
, ser_num SerNumType
, cut_off_qty QtyUnitType
)
declare @CycleUpdate table (
  RowPointer RowPointerType
, cut_off_qty QtyUnitType
)
declare @Itemwhse table (
  RowPointer RowPointerType primary key
)

set @Severity = 0
set @Infobar = null
set @Today = dbo.MidnightOf(dbo.GetSiteDate(getdate()))
set @NumProcessed = 0

SET @LowChar = dbo.LowCharacter()
SET @HighChar =  dbo.HighCharacter()

SET @FromPlanCode = ISNULL(@FromPlanCode, @LowChar)
SET @ToPlanCode = ISNULL(@ToPlanCode, @HighChar)
SET @FromItem = ISNULL(@FromItem, @LowChar)
SET @ToItem = ISNULL(@ToItem, @HighChar)
SET @FromLoc = ISNULL(@FromLoc, @LowChar)
SET @ToLoc = ISNULL(@ToLoc, @HighChar)
SET @FromZone = ISNULL(@FromZone, @LowChar)
SET @ToZone = ISNULL(@ToZone, @HighChar)
SET @FromProductCode = ISNULL(@FromProductCode, @LowChar)
SET @ToProductCode = ISNULL(@ToProductCode, @HighChar)
SET @FromFamilyCode = ISNULL(@FromFamilyCode, @LowChar)
SET @ToFamilyCode = ISNULL(@ToFamilyCode, @HighChar)

if exists (select 1 from whse with (readuncommitted) where whse.whse = @Whse and whse.phy_inv_flg = 1)
begin
   EXEC @Severity = dbo.MsgAppSp @Infobar OUTPUT
   , 'E=CmdFailed'
   , '@%process'
   EXEC @Severity = dbo.MsgAppSp @Infobar OUTPUT
   , 'E=IsCompare1'
   , '@whse.phy_inv_flg'
   , '@:ListYesNo:1'
   , '@whse'
   , '@whse.whse'
   , @Whse

   return @Severity
end

declare itemlocCrs cursor local static for
select itemloc.item, itemloc.loc, itemloc.qty_on_hand
, itemwhse.RowPointer, itemwhse.cycle_type, itemwhse.last_cycle
, itemwhse.cycle_freq, itemwhse.cycle_flag, itemwhse.cnt_in_proc
, item.lot_tracked, item.serial_tracked, item.stat
, location.description
from itemloc
   inner join itemwhse on
      itemwhse.item = itemloc.item
      and itemwhse.whse = @Whse
   inner join item on
      item.item = itemloc.item
      and item.product_code between @FromProductCode and @ToProductCode
      and isnull(item.family_code, @LowChar) between @FromFamilyCode and @ToFamilyCode
      and isnull(item.plan_code, @LowChar) between @FromPlanCode and @ToPlanCode
      and (@ABCCode is null or charindex(item.abc_code, @ABCCode) > 0)
      and (@MatlType is null or charindex(item.matl_type, @MatlType) > 0)
   inner join u_m with (readuncommitted) on
      u_m.u_m = item.u_m
   inner join location with (readuncommitted) on
      location.loc = itemloc.loc
      and isnull(location.ZWM_Zone, @LowChar) between @FromZone and @ToZone
where itemloc.whse = @Whse
and itemloc.loc_type = 'S'
and itemloc.item between @FromItem and @ToItem
and itemloc.loc between @FromLoc and @ToLoc
open itemlocCrs

while @Severity = 0
begin
   fetch itemlocCrs into
     @Item
   , @Loc
   , @ItemlocQtyOnHand
   , @ItemwhseRowPointer
   , @ItemwhseCycleType
   , @ItemwhseLastCycle
   , @ItemwhseCycleFreq
   , @ItemwhseCycleFlag
   , @ItemwhseCntInProc
   , @ItemLotTracked
   , @ItemSerialTracked
   , @ItemStat
   , @LocationDescription

   if @@fetch_status != 0
      break

   set @I = 1
   set @Flag = 0
   while @I <= len(@ItemwhseCycleType)
   begin
      if charindex(substring(@ItemwhseCycleType, @I, 1), @CycleType) > 0
      begin
         set @Flag = 1

         break
      end
      set @I = @I + 1
   end

   if @Flag = 0
      continue

   set @I = 1
   set @Flag = 0
   while @I <= len(@CycleType)
   begin
      set @C = substring(@CycleType, @I, 1)
      if @C = 'D' -- Day frequency
      begin
         if charindex(@C, @ItemwhseCycleType) > 0
         begin
            if DateDiff(dd,@ItemwhseLastCycle,@Today) >= @ItemwhseCycleFreq
            begin
               set @Flag = 1
               break
            end
         end
      END
      else if @ItemwhseCycleFlag = 1
      and charindex(@C, 'ZRI') > 0
      begin
         set @Flag = 1

         break
      end
      set @I = @I + 1
   end
   -- if this item did not trigger a cycle count
   if @Flag = 0
      continue

   set @HaveLotLoc = 0
   if @ItemLotTracked = 1
      if exists (select 1 from lot_loc WITH (READUNCOMMITTED) where lot_loc.whse = @Whse
      and lot_loc.item = @Item
      and lot_loc.loc = @Loc)
         set @HaveLotLoc = 1

   set @HaveSerial = 0
   if @ItemSerialTracked = 1
      if exists (select 1 from serial where serial.whse = @Whse
      and serial.item = @Item
      and serial.loc = @Loc
      and serial.stat != 'O')
         set @HaveSerial = 1

   set @CycleInProc = 0

   if @ItemSerialTracked = 1 and @HaveSerial = 1
   begin
      declare serialCrs cursor local static for
      select serial.lot, serial.ser_num
      from serial
      where serial.whse = @Whse
      and serial.item = @Item
      and serial.loc = @Loc
      and charindex(serial.stat, 'RIA') > 0
      order by serial.whse, serial.item, serial.loc, serial.lot, serial.ser_num

      open serialCrs

      while @Severity = 0
      begin
         fetch serialCrs into
           @SerialLot
         , @SerialSerNum

         if @@fetch_status != 0
            break

         if @ItemLotTracked = 1 and @HaveLotLoc = 1
            select @CycleRowPointer = cycle.RowPointer
            from cycle
            where cycle.whse = @Whse
            and cycle.item = @Item
            and cycle.loc = @Loc
            and cycle.ser_num = @SerialSerNum
            and cycle.lot = @SerialLot
         else
            select @CycleRowPointer = cycle.RowPointer
            from cycle
            where cycle.whse = @Whse
            and cycle.item = @Item
            and cycle.loc = @Loc
            and cycle.ser_num = @SerialSerNum
            and cycle.lot is null

         if @@rowcount = 0
         begin
            insert into @CycleNew
            values (@Item, @Loc, @SerialLot, @SerialSerNum, 1)

            set @CycleInProc = 1
         end
         else if @OverwriteRecords = 1
         begin
            insert into @CycleUpdate values(@CycleRowPointer, 1)

            set @CycleInProc = 1
         end
      end -- serial loop
      close serialCrs
      deallocate serialCrs
   end -- if @ItemSerialTracked = 1 and @HaveSerial = 1
   else if @ItemLotTracked = 1 and @HaveLotLoc = 1
   begin
      declare lotlocCrs cursor local static for
      select lot_loc.qty_on_hand, lot_loc.lot
      , cycle.RowPointer
      from lot_loc
         left outer join cycle on
            cycle.whse = lot_loc.whse
            and cycle.item = lot_loc.item
            and cycle.loc = lot_loc.loc
            and cycle.lot = lot_loc.lot
      where lot_loc.whse = @Whse
      and lot_loc.item = @Item
      and lot_loc.loc = @Loc
      order by lot_loc.whse, lot_loc.item, lot_loc.loc, lot_loc.lot

      open lotlocCrs

      while @Severity = 0
      begin
         fetch lotlocCrs into
           @LotLocQtyOnHand
         , @LotLocLot
         , @CycleRowPointer

         if @@fetch_status != 0
            break

         if @CycleRowPointer is null
         begin
            insert into @CycleNew
            values (@Item, @Loc, @LotLocLot, null, @LotLocQtyOnHand)

            set @CycleInProc = 1
         end
         else if @OverwriteRecords = 1
         begin
            insert into @CycleUpdate values(@CycleRowPointer, @LotLocQtyOnHand)

            set @CycleInProc = 1
         end
      end -- lot_loc loop
      close lotlocCrs
      deallocate lotlocCrs
   end -- if @ItemLotTracked = 1 and @HaveLotLoc = 1
   else if @HaveLotLoc = 0 and @HaveSerial = 0
   and (@ItemStat != 'O' or (@ItemStat = 'O' and @ItemlocQtyOnHand != 0))
   begin
      select @CycleRowPointer = cycle.RowPointer
      from cycle
      where cycle.whse = @Whse
      and cycle.item = @Item
      and cycle.loc = @Loc

      if @@rowcount = 0
      begin
         insert into @CycleNew
         values (@Item, @Loc, null, null, @ItemlocQtyOnHand)

         set @CycleInProc = 1
      end
      else if @OverwriteRecords = 1
      begin
         insert into @CycleUpdate values(@CycleRowPointer, @ItemlocQtyOnHand)

         set @CycleInProc = 1
      end
   end -- not lot- or serial-tracked

   if @CycleInProc = 1 and @ItemwhseCntInProc = 0
      if not exists (select 1 from @Itemwhse where RowPointer = @ItemwhseRowPointer)
         insert into @Itemwhse values(@ItemwhseRowPointer)
end -- itemloc loop

close itemlocCrs
deallocate itemlocCrs

set @NumProcessed = 0
insert into cycle (whse, item, loc, lot, ser_num
, cut_off_qty, count_qty, stat, cycle_date)
select @Whse, item, loc, lot, ser_num
, cut_off_qty, NULL, 'N', @Today
from @CycleNew
set @NumProcessed = @NumProcessed + @@rowcount

update cycle
set cut_off_qty = buf.cut_off_qty
, count_qty = null
, stat = 'N'
, cycle_date = @Today
from @CycleUpdate as buf
where cycle.RowPointer = buf.RowPointer
set @NumProcessed = @NumProcessed + @@rowcount

update itemwhse
set cnt_in_proc = 1
from @Itemwhse as iw
where itemwhse.RowPointer = iw.RowPointer


EXEC @Severity = dbo.MsgAppSp @Infobar OUTPUT   , 'I=#Processed'
                                          , @NumProcessed
                                          , '@cycle'

return 0

GO


